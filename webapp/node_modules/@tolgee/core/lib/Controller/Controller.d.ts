import { CacheDescriptor, NsFallback, TolgeeOptions, TFnType, KeyAndNamespacesInternal } from '../types';
declare type StateServiceProps = {
    options?: Partial<TolgeeOptions>;
};
export declare const Controller: ({ options }: StateServiceProps) => Readonly<{
    init: (options: Partial<TolgeeOptions>) => void;
    changeLanguage: (language: string) => Promise<void>;
    getTranslation: ({ key, ns }: KeyAndNamespacesInternal) => string | undefined;
    changeTranslation: (descriptor: CacheDescriptor, key: string, value: string) => {
        revert: () => void;
    };
    addActiveNs: (ns: NsFallback, forget?: boolean) => Promise<void>;
    loadRecords: (descriptors: CacheDescriptor[]) => Promise<import("../types").TranslationsFlat[]>;
    loadRecord: (descriptor: CacheDescriptor) => Promise<import("../types").TranslationsFlat>;
    isLoading: (ns?: NsFallback) => boolean;
    isLoaded: (ns?: NsFallback) => boolean;
    t: TFnType<import("../types").DefaultParamType, string>;
    isDev: () => boolean;
    run: () => Promise<void | undefined>;
    stop: () => void;
    addStaticData: (data: import("./State/initState").TolgeeStaticData | undefined) => void;
    invalidate: () => void;
    addRecord: (descriptor: import("../types").CacheDescriptorInternal, data: import("../types").TreeTranslationsData) => void;
    exists: (descriptor: import("../types").CacheDescriptorInternal, strict?: boolean) => boolean;
    getRecord: (descriptor: CacheDescriptor) => import("../types").TranslationsFlat | undefined;
    getTranslationNs: (namespaces: string[], languages: string[], key: string) => string[];
    getTranslationFallback: (namespaces: string[], languages: string[], key: string) => string | undefined;
    isFetching: (ns?: NsFallback) => boolean;
    getAllRecords: () => {
        data: import("../types").TranslationsFlat;
        language: string;
        namespace: string;
    }[];
    addPlugin: (tolgeeInstance: Readonly<{
        on: import("../types").TolgeeOn<keyof import("../types").EventType>;
        onNsUpdate: (handler: import("../types").Listener<undefined>) => import("../types").SubscriptionSelective;
        setEmmiterActive: (active: boolean) => void;
        getLanguage: () => string | undefined;
        getPendingLanguage: () => string | undefined;
        changeLanguage: (language: string) => Promise<void>;
        changeTranslation: (descriptor: CacheDescriptor, key: string, value: string) => {
            revert: () => void;
        };
        addActiveNs: (ns: NsFallback, forget?: boolean) => Promise<void>;
        removeActiveNs: (ns: NsFallback) => void;
        loadRecords: (descriptors: CacheDescriptor[]) => Promise<import("../types").TranslationsFlat[]>;
        loadRecord: (descriptor: CacheDescriptor) => Promise<import("../types").TranslationsFlat>;
        addStaticData: (data: import("./State/initState").TolgeeStaticData | undefined) => void;
        getRecord: (descriptor: CacheDescriptor) => import("../types").TranslationsFlat | undefined;
        getAllRecords: () => {
            data: import("../types").TranslationsFlat;
            language: string;
            namespace: string;
        }[];
        isLoaded: (ns?: NsFallback) => boolean;
        isInitialLoading: () => boolean;
        isLoading: (ns?: NsFallback) => boolean;
        isFetching: (ns?: NsFallback) => boolean;
        isRunning: () => boolean;
        run: () => Promise<void | undefined>;
        stop: () => void;
        t: TFnType<import("../types").DefaultParamType, string>;
        highlight: import("../types").HighlightInterface;
        getInitialOptions: () => {
            apiUrl?: string | undefined;
            apiKey?: string | undefined;
            projectId?: string | number | undefined;
            language?: string | undefined;
            defaultLanguage?: string | undefined;
            availableLanguages?: string[] | undefined;
            fallbackLanguage?: import("../types").FallbackLanguageOption;
            ns?: string[] | undefined;
            fallbackNs?: import("../types").FallbackGeneral;
            defaultNs: string;
            staticData?: import("./State/initState").TolgeeStaticData | undefined;
            observerType: "invisible" | "text";
            observerOptions: import("./State/observerOptions").ObserverOptionsInternal;
            onFormatError: import("../types").OnFormatError;
        };
        isDev: () => boolean;
        wrap: (params: import("../types").WrapperWrapProps) => string | undefined;
        unwrap: (text: string) => import("../types").Unwrapped;
        overrideCredentials(credentials: import("../types").DevCredentials): void;
        addPlugin(plugin: import("../types").TolgeePlugin | undefined): void;
        updateOptions(options?: TolgeeOptions | undefined): void;
    }>, plugin: import("../types").TolgeePlugin) => void;
    formatTranslation: ({ formatEnabled, ...props }: {
        key: string;
        defaultValue?: string | undefined;
        params?: import("../types").TranslateParams<import("../types").DefaultParamType> | undefined;
    } & import("../types").TranslateOptions & {
        translation?: string | undefined;
    } & {
        formatEnabled?: boolean | undefined;
    }) => string;
    getDevBackend: () => import("../types").BackendDevMiddleware | undefined;
    getBackendRecord: import("../types").BackendGetRecord;
    getBackendDevRecord: import("../types").BackendGetRecord;
    getLanguageDetector: () => import("../types").LanguageDetectorMiddleware | undefined;
    getLanguageStorage: () => import("../types").LanguageStorageMiddleware | undefined;
    getInitialLanguage: () => string | Promise<string | undefined> | Promise<string | Promise<string | undefined> | undefined> | undefined;
    setStoredLanguage: (language: string) => void;
    retranslate: () => void;
    highlight: import("../types").HighlightInterface;
    unwrap: (text: string) => import("../types").Unwrapped;
    wrap: (params: import("../types").WrapperWrapProps) => string | undefined;
    hasDevBackend: () => boolean;
    isRunning: () => boolean;
    setRunning: (value: boolean) => void;
    isInitialLoading: () => boolean;
    setInitialLoading: (value: boolean) => void;
    getLanguage: () => string | undefined;
    setLanguage: (language: string) => void;
    getPendingLanguage: () => string | undefined;
    setPendingLanguage: (language: string) => void;
    getInitialOptions: () => {
        apiUrl?: string | undefined;
        apiKey?: string | undefined;
        projectId?: string | number | undefined;
        language?: string | undefined;
        defaultLanguage?: string | undefined;
        availableLanguages?: string[] | undefined;
        fallbackLanguage?: import("../types").FallbackLanguageOption;
        ns?: string[] | undefined;
        fallbackNs?: import("../types").FallbackGeneral;
        defaultNs: string;
        staticData?: import("./State/initState").TolgeeStaticData | undefined;
        observerType: "invisible" | "text";
        observerOptions: import("./State/observerOptions").ObserverOptionsInternal;
        onFormatError: import("../types").OnFormatError;
    };
    removeActiveNs: (ns: NsFallback) => void;
    getRequiredNamespaces: () => string[];
    getFallbackLangs: (lang?: string | undefined) => string[];
    getFallbackNs: () => string[];
    getDefaultNs: (ns?: string | undefined) => string;
    getAvailableLanguages: () => string[] | undefined;
    withDefaultNs: (descriptor: CacheDescriptor) => import("../types").CacheDescriptorInternal;
    overrideCredentials: (credentials: import("../types").DevCredentials) => void;
    onPendingLanguageChange: import("./Events/EventEmitter").EventEmitterInstance<string>;
    onLanguageChange: import("./Events/EventEmitter").EventEmitterInstance<string>;
    onLoadingChange: import("./Events/EventEmitter").EventEmitterInstance<boolean>;
    onFetchingChange: import("./Events/EventEmitter").EventEmitterInstance<boolean>;
    onInitialLoaded: import("./Events/EventEmitter").EventEmitterInstance<void>;
    onRunningChange: import("./Events/EventEmitter").EventEmitterInstance<boolean>;
    onCacheChange: import("./Events/EventEmitter").EventEmitterInstance<import("../types").CacheDescriptorWithKey>;
    onUpdate: import("./Events/EventEmitterSelective").EventEmitterSelectiveInstance;
    setEmmiterActive: (active: boolean) => void;
    on: import("../types").TolgeeOn<keyof import("../types").EventType>;
}>;
export declare type ControllerInstance = ReturnType<typeof Controller>;
export {};
