import React, { useState, useEffect, Suspense, useContext, useCallback, useRef } from 'react';
import { getFallback, getFallbackArray, getTranslateProps } from '@tolgee/web';
export * from '@tolgee/web';

const DEFAULT_REACT_OPTIONS = {
    useSuspense: true,
};
const TolgeeProviderContext = React.createContext(undefined);
const TolgeeProvider = ({ tolgee, options, children, fallback, }) => {
    const [loading, setLoading] = useState(!tolgee.isLoaded());
    useEffect(() => {
        tolgee.run().finally(() => {
            setLoading(false);
        });
        return () => {
            tolgee.stop();
        };
    }, [tolgee]);
    const optionsWithDefault = Object.assign(Object.assign({}, DEFAULT_REACT_OPTIONS), options);
    if (optionsWithDefault.useSuspense) {
        return (React.createElement(TolgeeProviderContext.Provider, { value: { tolgee, options: optionsWithDefault } }, loading ? (fallback) : (React.createElement(Suspense, { fallback: fallback || null }, children))));
    }
    return (React.createElement(TolgeeProviderContext.Provider, { value: { tolgee, options: optionsWithDefault } }, loading ? fallback : children));
};

let globalContext;
const GlobalContextPlugin = (options) => (tolgee) => {
    globalContext = {
        tolgee,
        options: Object.assign(Object.assign({}, DEFAULT_REACT_OPTIONS), options),
    };
    return tolgee;
};
function getGlobalContext() {
    return globalContext;
}

const useTolgeeContext = () => {
    const context = useContext(TolgeeProviderContext) || getGlobalContext();
    if (!context) {
        throw new Error("Couldn't find tolgee instance, did you forgot to use `TolgeeProvider`?");
    }
    return context;
};

const useRerender = () => {
    const [instance, setCounter] = useState(0);
    const rerender = useCallback(() => {
        setCounter((num) => num + 1);
    }, [setCounter]);
    return { instance, rerender };
};

const useTranslateInternal = (ns, options) => {
    const { tolgee, options: defaultOptions } = useTolgeeContext();
    const namespaces = getFallback(ns);
    const namespacesJoined = getFallbackArray(namespaces).join(':');
    const currentOptions = Object.assign(Object.assign({}, defaultOptions), options);
    // dummy state to enable re-rendering
    const { rerender, instance } = useRerender();
    const subscriptionRef = useRef();
    const subscriptionQueue = useRef([]);
    subscriptionQueue.current = [];
    const subscribeToNs = (ns) => {
        var _a;
        subscriptionQueue.current.push(ns);
        (_a = subscriptionRef.current) === null || _a === void 0 ? void 0 : _a.subscribeNs(ns);
    };
    const isLoaded = tolgee.isLoaded(namespaces);
    useEffect(() => {
        const subscription = tolgee.onNsUpdate(rerender);
        subscriptionRef.current = subscription;
        if (!isLoaded) {
            subscription.subscribeNs(namespaces);
        }
        subscriptionQueue.current.forEach((ns) => {
            subscription.subscribeNs(ns);
        });
        return () => {
            subscription.unsubscribe();
        };
    }, [isLoaded, namespacesJoined, tolgee]);
    useEffect(() => {
        tolgee.addActiveNs(namespaces);
        return () => tolgee.removeActiveNs(namespaces);
    }, [namespacesJoined, tolgee]);
    const t = useCallback((props) => {
        var _a;
        const fallbackNs = (_a = props.ns) !== null && _a !== void 0 ? _a : namespaces === null || namespaces === void 0 ? void 0 : namespaces[0];
        subscribeToNs(fallbackNs);
        return tolgee.t(Object.assign(Object.assign({}, props), { ns: fallbackNs }));
    }, [tolgee, instance]);
    if (currentOptions.useSuspense && !isLoaded) {
        throw tolgee.addActiveNs(namespaces, true);
    }
    return { t, isLoading: !isLoaded };
};

const useTranslate = (ns, options) => {
    const { t: tInternal, isLoading } = useTranslateInternal(ns, options);
    const t = useCallback((...params) => {
        // @ts-ignore
        const props = getTranslateProps(...params);
        return tInternal(props);
    }, [tInternal]);
    return { t, isLoading };
};

const wrapTagHandlers = (params) => {
    if (!params) {
        return undefined;
    }
    const result = {};
    Object.entries(params || {}).forEach(([key, value]) => {
        if (typeof value === 'function') {
            result[key] = (chunk) => {
                return value(addReactKeys(chunk));
            };
        }
        else if (React.isValidElement(value)) {
            const el = value;
            result[key] = (chunk) => {
                return el.props.children !== undefined
                    ? React.cloneElement(el)
                    : React.cloneElement(el, {}, addReactKeys(chunk));
            };
        }
        else {
            result[key] = value;
        }
    });
    return result;
};
const addReactKeys = (val) => {
    if (Array.isArray(val)) {
        return React.Children.toArray(val);
    }
    else {
        return val;
    }
};

const T = (props) => {
    const key = props.keyName || props.children;
    if (key === undefined) {
        // eslint-disable-next-line no-console
        console.error('T component: keyName not defined');
    }
    const defaultValue = props.defaultValue || (props.keyName ? props.children : undefined);
    const { t } = useTranslateInternal();
    const translation = addReactKeys(t({
        key: key,
        params: wrapTagHandlers(props.params),
        defaultValue,
        noWrap: props.noWrap,
        ns: props.ns,
    }));
    return React.createElement(React.Fragment, null, translation);
};

const useTolgee = (events) => {
    const { tolgee } = useTolgeeContext();
    const { rerender } = useRerender();
    useEffect(() => {
        const listeners = events === null || events === void 0 ? void 0 : events.map((e) => tolgee.on(e, rerender));
        return () => {
            listeners === null || listeners === void 0 ? void 0 : listeners.forEach((listener) => listener.unsubscribe());
        };
    }, [events === null || events === void 0 ? void 0 : events.join(':')]);
    return tolgee;
};

export { GlobalContextPlugin, T, TolgeeProvider, TolgeeProviderContext, useTolgee, useTranslate };
//# sourceMappingURL=tolgee-react.esm.js.map
