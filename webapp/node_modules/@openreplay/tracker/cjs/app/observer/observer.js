"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_js_1 = require("../../messages/index.js");
const context_js_1 = require("../context.js");
function isSVGElement(node) {
    return node.namespaceURI === 'http://www.w3.org/2000/svg';
}
function isIgnored(node) {
    if ((0, context_js_1.isInstance)(node, Text)) {
        return false;
    }
    if (!(0, context_js_1.isInstance)(node, Element)) {
        return true;
    }
    const tag = node.tagName.toUpperCase();
    if (tag === 'LINK') {
        const rel = node.getAttribute('rel');
        const as = node.getAttribute('as');
        return !((rel === null || rel === void 0 ? void 0 : rel.includes('stylesheet')) || as === "style" || as === "font");
    }
    return (tag === 'SCRIPT' ||
        tag === 'NOSCRIPT' ||
        tag === 'META' ||
        tag === 'TITLE' ||
        tag === 'BASE');
}
function isRootNode(node) {
    return (0, context_js_1.isInstance)(node, Document) || (0, context_js_1.isInstance)(node, ShadowRoot);
}
function isObservable(node) {
    if (isRootNode(node)) {
        return true;
    }
    return !isIgnored(node);
}
class Observer {
    constructor(app, isTopContext = false) {
        this.app = app;
        this.isTopContext = isTopContext;
        this.commited = [];
        this.recents = [];
        this.myNodes = [];
        this.indexes = [];
        this.attributesList = [];
        this.textSet = new Set();
        this.observer = new MutationObserver(this.app.safe((mutations) => {
            for (const mutation of mutations) {
                const target = mutation.target;
                const type = mutation.type;
                if (!isObservable(target) || !(0, context_js_1.inDocument)(target)) {
                    continue;
                }
                if (type === 'childList') {
                    for (let i = 0; i < mutation.removedNodes.length; i++) {
                        this.bindTree(mutation.removedNodes[i]);
                    }
                    for (let i = 0; i < mutation.addedNodes.length; i++) {
                        this.bindTree(mutation.addedNodes[i]);
                    }
                    continue;
                }
                const id = this.app.nodes.getID(target);
                if (id === undefined) {
                    continue;
                }
                if (id >= this.recents.length) { // TODO: something more convinient
                    this.recents[id] = undefined;
                }
                if (type === 'attributes') {
                    const name = mutation.attributeName;
                    if (name === null) {
                        continue;
                    }
                    let attr = this.attributesList[id];
                    if (attr === undefined) {
                        this.attributesList[id] = attr = new Set();
                    }
                    attr.add(name);
                    continue;
                }
                if (type === 'characterData') {
                    this.textSet.add(id);
                    continue;
                }
            }
            this.commitNodes();
        }));
    }
    clear() {
        this.commited.length = 0;
        this.recents.length = 0;
        this.indexes.length = 1;
        this.attributesList.length = 0;
        this.textSet.clear();
    }
    sendNodeAttribute(id, node, name, value) {
        if (isSVGElement(node)) {
            if (name.substr(0, 6) === 'xlink:') {
                name = name.substr(6);
            }
            if (value === null) {
                this.app.send(new index_js_1.RemoveNodeAttribute(id, name));
            }
            else if (name === 'href') {
                if (value.length > 1e5) {
                    value = '';
                }
                this.app.send(new index_js_1.SetNodeAttributeURLBased(id, name, value, this.app.getBaseHref()));
            }
            else {
                this.app.send(new index_js_1.SetNodeAttribute(id, name, value));
            }
            return;
        }
        if (name === 'src' ||
            name === 'srcset' ||
            name === 'integrity' ||
            name === 'crossorigin' ||
            name === 'autocomplete' ||
            name.substr(0, 2) === 'on') {
            return;
        }
        if (name === 'value' &&
            (0, context_js_1.isInstance)(node, HTMLInputElement) &&
            node.type !== 'button' &&
            node.type !== 'reset' &&
            node.type !== 'submit') {
            return;
        }
        if (value === null) {
            this.app.send(new index_js_1.RemoveNodeAttribute(id, name));
            return;
        }
        if (name === 'style' || name === 'href' && (0, context_js_1.isInstance)(node, HTMLLinkElement)) {
            this.app.send(new index_js_1.SetNodeAttributeURLBased(id, name, value, this.app.getBaseHref()));
            return;
        }
        if (name === 'href' || value.length > 1e5) {
            value = '';
        }
        this.app.send(new index_js_1.SetNodeAttribute(id, name, value));
    }
    sendNodeData(id, parentElement, data) {
        if ((0, context_js_1.isInstance)(parentElement, HTMLStyleElement) || (0, context_js_1.isInstance)(parentElement, SVGStyleElement)) {
            this.app.send(new index_js_1.SetCSSDataURLBased(id, data, this.app.getBaseHref()));
            return;
        }
        data = this.app.sanitizer.sanitize(id, data);
        this.app.send(new index_js_1.SetNodeData(id, data));
    }
    bindNode(node) {
        const r = this.app.nodes.registerNode(node);
        const id = r[0];
        this.recents[id] = r[1] || this.recents[id] || false;
        this.myNodes[id] = true;
    }
    bindTree(node) {
        if (!isObservable(node)) {
            return;
        }
        this.bindNode(node);
        const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT, {
            acceptNode: (node) => isIgnored(node) || this.app.nodes.getID(node) !== undefined
                ? NodeFilter.FILTER_REJECT
                : NodeFilter.FILTER_ACCEPT,
        }, 
        // @ts-ignore
        false);
        while (walker.nextNode()) {
            this.bindNode(walker.currentNode);
        }
    }
    unbindNode(node) {
        const id = this.app.nodes.unregisterNode(node);
        if (id !== undefined && this.recents[id] === false) {
            this.app.send(new index_js_1.RemoveNode(id));
        }
    }
    _commitNode(id, node) {
        if (isRootNode(node)) {
            return true;
        }
        const parent = node.parentNode;
        let parentID;
        // Disable parent check for the upper context HTMLHtmlElement, because it is root there... (before)
        // TODO: get rid of "special" cases (there is an issue with CreateDocument altered behaviour though)
        // TODO: Clean the logic (though now it workd fine) 
        if (!(0, context_js_1.isInstance)(node, HTMLHtmlElement) || !this.isTopContext) {
            if (parent === null) {
                this.unbindNode(node);
                return false;
            }
            parentID = this.app.nodes.getID(parent);
            if (parentID === undefined) {
                this.unbindNode(node);
                return false;
            }
            if (!this.commitNode(parentID)) {
                this.unbindNode(node);
                return false;
            }
            this.app.sanitizer.handleNode(id, parentID, node);
        }
        let sibling = node.previousSibling;
        while (sibling !== null) {
            const siblingID = this.app.nodes.getID(sibling);
            if (siblingID !== undefined) {
                this.commitNode(siblingID);
                this.indexes[id] = this.indexes[siblingID] + 1;
                break;
            }
            sibling = sibling.previousSibling;
        }
        if (sibling === null) {
            this.indexes[id] = 0; //
        }
        const isNew = this.recents[id];
        const index = this.indexes[id];
        if (index === undefined) {
            throw 'commitNode: missing node index';
        }
        if (isNew === true) {
            if ((0, context_js_1.isInstance)(node, Element)) {
                if (parentID !== undefined) {
                    this.app.send(new index_js_1.CreateElementNode(id, parentID, index, node.tagName, isSVGElement(node)));
                }
                for (let i = 0; i < node.attributes.length; i++) {
                    const attr = node.attributes[i];
                    this.sendNodeAttribute(id, node, attr.nodeName, attr.value);
                }
            }
            else if ((0, context_js_1.isInstance)(node, Text)) {
                // for text node id != 0, hence parentID !== undefined and parent is Element
                this.app.send(new index_js_1.CreateTextNode(id, parentID, index));
                this.sendNodeData(id, parent, node.data);
            }
            return true;
        }
        if (isNew === false && parentID !== undefined) {
            this.app.send(new index_js_1.MoveNode(id, parentID, index));
        }
        const attr = this.attributesList[id];
        if (attr !== undefined) {
            if (!(0, context_js_1.isInstance)(node, Element)) {
                throw 'commitNode: node is not an element';
            }
            for (const name of attr) {
                this.sendNodeAttribute(id, node, name, node.getAttribute(name));
            }
        }
        if (this.textSet.has(id)) {
            if (!(0, context_js_1.isInstance)(node, Text)) {
                throw 'commitNode: node is not a text';
            }
            // for text node id != 0, hence parent is Element
            this.sendNodeData(id, parent, node.data);
        }
        return true;
    }
    commitNode(id) {
        const node = this.app.nodes.getNode(id);
        if (node === undefined) {
            return false;
        }
        const cmt = this.commited[id];
        if (cmt !== undefined) {
            return cmt;
        }
        return (this.commited[id] = this._commitNode(id, node));
    }
    commitNodes() {
        let node;
        for (let id = 0; id < this.recents.length; id++) {
            // TODO: make things/logic nice here.
            // commit required in any case if recents[id] true or false (in case of unbinding) or undefined (in case of attr change).
            // Possible solution: separate new node commit (recents) and new attribute/move node commit
            // Otherwise commitNode is called on each node, which might be a lot
            if (!this.myNodes[id]) {
                continue;
            }
            this.commitNode(id);
            if (this.recents[id] === true && (node = this.app.nodes.getNode(id))) {
                this.app.nodes.callNodeCallbacks(node);
            }
        }
        this.clear();
    }
    // ISSSUE
    observeRoot(node, beforeCommit, nodeToBind = node) {
        this.observer.observe(node, {
            childList: true,
            attributes: true,
            characterData: true,
            subtree: true,
            attributeOldValue: false,
            characterDataOldValue: false,
        });
        this.bindTree(nodeToBind);
        beforeCommit(this.app.nodes.getID(node));
        this.commitNodes();
    }
    disconnect() {
        this.observer.disconnect();
        this.clear();
        this.myNodes.length = 0;
    }
}
exports.default = Observer;
