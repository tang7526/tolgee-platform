(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["@tolgee/core"] = {}));
})(this, (function (exports) { 'use strict';

    function isPromise(value) {
        return Boolean(value && typeof value.then === 'function');
    }
    const valueOrPromise = (value, callback) => {
        if (isPromise(value)) {
            return Promise.resolve(value).then(callback);
        }
        else {
            return callback(value);
        }
    };
    const missingOptionError = (option) => `Tolgee: You need to specify '${option}' option`;
    function isObject(item) {
        return typeof item === 'object' && !Array.isArray(item) && item !== null;
    }
    function getFallback(value) {
        if (typeof value === 'string') {
            return [value];
        }
        if (Array.isArray(value)) {
            return value;
        }
        return undefined;
    }
    function getFallbackArray(value) {
        return getFallback(value) || [];
    }
    function getFallbackFromStruct(language, fallbackLanguage) {
        if (isObject(fallbackLanguage)) {
            return getFallbackArray(fallbackLanguage === null || fallbackLanguage === void 0 ? void 0 : fallbackLanguage[language]);
        }
        else {
            return getFallbackArray(fallbackLanguage);
        }
    }
    function unique(arr) {
        return Array.from(new Set(arr));
    }
    function sanitizeUrl(url) {
        return url ? url.replace(/\/+$/, '') : url;
    }
    function getErrorMessage(error) {
        if (typeof error === 'string') {
            return error;
        }
        else if (typeof (error === null || error === void 0 ? void 0 : error.message) === 'string') {
            return error.message;
        }
    }

    const EventEmitter = (isActive) => {
        let handlers = [];
        const listen = (handler) => {
            const handlerWrapper = (e) => {
                handler(e);
            };
            handlers.push(handlerWrapper);
            return {
                unsubscribe: () => {
                    handlers = handlers.filter((i) => handlerWrapper !== i);
                },
            };
        };
        const emit = (data) => {
            if (isActive()) {
                handlers.forEach((handler) => handler({ value: data }));
            }
        };
        return Object.freeze({ listen, emit });
    };

    const EventEmitterSelective = (isActive, getFallbackNs, getDefaultNs) => {
        const listeners = new Set();
        const partialListeners = new Set();
        const listen = (handler) => {
            listeners.add(handler);
            const result = {
                unsubscribe: () => {
                    listeners.delete(handler);
                },
            };
            return result;
        };
        const listenSome = (handler) => {
            const handlerWrapper = {
                fn: (e) => {
                    handler(e);
                },
                namespaces: new Set(),
            };
            partialListeners.add(handlerWrapper);
            const result = {
                unsubscribe: () => {
                    partialListeners.delete(handlerWrapper);
                },
                subscribeNs: (ns) => {
                    getFallbackArray(ns).forEach((val) => handlerWrapper.namespaces.add(val));
                    if (ns === undefined) {
                        // subscribing to default ns
                        handlerWrapper.namespaces.add(getDefaultNs());
                    }
                    return result;
                },
            };
            return result;
        };
        const callHandlers = (ns) => {
            // everything is implicitly subscribed to fallbacks
            // as it can always fall through to it
            const fallbackNamespaces = new Set(getFallbackNs());
            partialListeners.forEach((handler) => {
                const nsMatches = ns === undefined ||
                    (ns === null || ns === void 0 ? void 0 : ns.findIndex((ns) => fallbackNamespaces.has(ns) || handler.namespaces.has(ns))) !== -1;
                if (nsMatches) {
                    handler.fn({ value: undefined });
                }
            });
        };
        let queue = [];
        // merge events in queue into one event
        const solveQueue = () => {
            if (queue.length === 0) {
                return;
            }
            const queueCopy = queue;
            queue = [];
            listeners.forEach((handler) => {
                handler({ value: undefined });
            });
            let namespaces = new Set();
            queueCopy.forEach((ns) => {
                if (ns === undefined) {
                    // when no ns specified, it affects all namespaces
                    namespaces = undefined;
                }
                else if (namespaces !== undefined) {
                    ns.forEach((ns) => namespaces.add(ns));
                }
            });
            const namespacesArray = namespaces
                ? Array.from(namespaces.keys())
                : undefined;
            callHandlers(namespacesArray);
        };
        const emit = (ns, delayed) => {
            if (isActive()) {
                queue.push(ns);
                if (!delayed) {
                    solveQueue();
                }
                else {
                    setTimeout(solveQueue, 0);
                }
            }
        };
        return Object.freeze({ listenSome, listen, emit });
    };

    const Events = (getFallbackNs, getDefaultNs) => {
        let emitterActive = true;
        function isActive() {
            return emitterActive;
        }
        const onPendingLanguageChange = EventEmitter(isActive);
        const onLanguageChange = EventEmitter(isActive);
        const onLoadingChange = EventEmitter(isActive);
        const onFetchingChange = EventEmitter(isActive);
        const onInitialLoaded = EventEmitter(isActive);
        const onRunningChange = EventEmitter(isActive);
        const onCacheChange = EventEmitter(isActive);
        const onUpdate = EventEmitterSelective(isActive, getFallbackNs, getDefaultNs);
        onInitialLoaded.listen(() => onUpdate.emit());
        onLanguageChange.listen(() => onUpdate.emit());
        onCacheChange.listen(({ value }) => {
            onUpdate.emit([value.namespace], true);
        });
        const on = (event, handler) => {
            switch (event) {
                case 'pendingLanguage':
                    return onPendingLanguageChange.listen(handler);
                case 'language':
                    return onLanguageChange.listen(handler);
                case 'loading':
                    return onLoadingChange.listen(handler);
                case 'fetching':
                    return onFetchingChange.listen(handler);
                case 'initialLoad':
                    return onInitialLoaded.listen(handler);
                case 'running':
                    return onRunningChange.listen(handler);
                case 'cache':
                    return onCacheChange.listen(handler);
                case 'update':
                    return onUpdate.listen(handler);
            }
        };
        function setEmmiterActive(active) {
            emitterActive = active;
        }
        return Object.freeze({
            onPendingLanguageChange,
            onLanguageChange,
            onLoadingChange,
            onFetchingChange,
            onInitialLoaded,
            onRunningChange,
            onCacheChange,
            onUpdate,
            setEmmiterActive,
            on,
        });
    };

    const flattenTranslations = (data) => {
        const result = new Map();
        Object.entries(data).forEach(([key, value]) => {
            // ignore empty values
            if (value === undefined || value === null) {
                return;
            }
            if (typeof value === 'object') {
                flattenTranslations(value).forEach((flatValue, flatKey) => {
                    result.set(key + '.' + flatKey, flatValue);
                });
                return;
            }
            result.set(key, value);
        });
        return result;
    };
    const decodeCacheKey = (key) => {
        const [firstPart, ...rest] = key.split(':');
        // if namespaces contains ":" it won't get lost
        const secondPart = rest.join(':');
        return { language: firstPart, namespace: secondPart || '' };
    };
    const encodeCacheKey = ({ language, namespace, }) => {
        if (namespace) {
            return `${language}:${namespace}`;
        }
        else {
            return language;
        }
    };

    const Cache = (onCacheChange, backendGetRecord, backendGetDevRecord, withDefaultNs, isInitialLoading, fetchingObserver, loadingObserver) => {
        const asyncRequests = new Map();
        const cache = new Map();
        let staticData = {};
        let version = 0;
        function addStaticData(data) {
            if (data) {
                staticData = Object.assign(Object.assign({}, staticData), data);
                Object.entries(data).forEach(([key, value]) => {
                    if (typeof value !== 'function') {
                        const descriptor = decodeCacheKey(key);
                        const existing = cache.get(key);
                        if (!existing || existing.version === 0) {
                            addRecordInternal(descriptor, value, 0);
                        }
                    }
                });
            }
        }
        function invalidate() {
            asyncRequests.clear();
            version += 1;
        }
        function addRecordInternal(descriptor, data, recordVersion) {
            const cacheKey = encodeCacheKey(descriptor);
            cache.set(cacheKey, {
                data: flattenTranslations(data),
                version: recordVersion,
            });
            onCacheChange.emit(descriptor);
        }
        function addRecord(descriptor, data) {
            addRecordInternal(descriptor, data, version);
        }
        function exists(descriptor, strict = false) {
            const record = cache.get(encodeCacheKey(descriptor));
            if (record && strict) {
                return record.version === version;
            }
            return Boolean(record);
        }
        function getRecord(descriptor) {
            var _a;
            return (_a = cache.get(encodeCacheKey(withDefaultNs(descriptor)))) === null || _a === void 0 ? void 0 : _a.data;
        }
        function getTranslation(descriptor, key) {
            var _a;
            return (_a = cache.get(encodeCacheKey(descriptor))) === null || _a === void 0 ? void 0 : _a.data.get(key);
        }
        function getTranslationNs(namespaces, languages, key) {
            var _a;
            for (const namespace of namespaces) {
                for (const language of languages) {
                    const value = (_a = cache
                        .get(encodeCacheKey({ language, namespace }))) === null || _a === void 0 ? void 0 : _a.data.get(key);
                    if (value !== undefined && value !== null) {
                        return [namespace];
                    }
                }
            }
            return unique(namespaces);
        }
        function getTranslationFallback(namespaces, languages, key) {
            var _a;
            for (const namespace of namespaces) {
                for (const language of languages) {
                    const value = (_a = cache
                        .get(encodeCacheKey({ language, namespace }))) === null || _a === void 0 ? void 0 : _a.data.get(key);
                    if (value !== undefined && value !== null) {
                        return value;
                    }
                }
            }
            return undefined;
        }
        function changeTranslation(descriptor, key, value) {
            var _a;
            const record = (_a = cache.get(encodeCacheKey(descriptor))) === null || _a === void 0 ? void 0 : _a.data;
            record === null || record === void 0 ? void 0 : record.set(key, value);
            onCacheChange.emit(Object.assign(Object.assign({}, descriptor), { key }));
        }
        function isFetching(ns) {
            if (isInitialLoading()) {
                return true;
            }
            if (ns === undefined) {
                return asyncRequests.size > 0;
            }
            const namespaces = getFallbackArray(ns);
            return Boolean(Array.from(asyncRequests.keys()).find((key) => namespaces.includes(decodeCacheKey(key).namespace)));
        }
        function isLoading(language, ns) {
            const namespaces = getFallbackArray(ns);
            return Boolean(isInitialLoading() ||
                Array.from(asyncRequests.keys()).find((key) => {
                    const descriptor = decodeCacheKey(key);
                    return ((!namespaces.length || namespaces.includes(descriptor.namespace)) &&
                        !exists({
                            namespace: descriptor.namespace,
                            language: language,
                        }));
                }));
        }
        /**
         * Fetches production data
         */
        function fetchProd(keyObject) {
            let dataPromise = undefined;
            if (!dataPromise) {
                const staticDataValue = staticData[encodeCacheKey(keyObject)];
                if (typeof staticDataValue === 'function') {
                    dataPromise = staticDataValue();
                }
            }
            if (!dataPromise) {
                dataPromise = backendGetRecord(keyObject);
            }
            return dataPromise;
        }
        function fetchData(keyObject, isDev) {
            var _a;
            let dataPromise = undefined;
            if (isDev) {
                dataPromise = (_a = backendGetDevRecord(keyObject)) === null || _a === void 0 ? void 0 : _a.catch(() => {
                    // eslint-disable-next-line no-console
                    console.warn(`Tolgee: Failed to fetch data from dev backend`);
                    // fallback to prod fetch if dev fails
                    return fetchProd(keyObject);
                });
            }
            if (!dataPromise) {
                dataPromise = fetchProd(keyObject);
            }
            return dataPromise;
        }
        async function loadRecords(descriptors, isDev) {
            const withPromises = descriptors.map((descriptor) => {
                const keyObject = withDefaultNs(descriptor);
                const cacheKey = encodeCacheKey(keyObject);
                const existingPromise = asyncRequests.get(cacheKey);
                if (existingPromise) {
                    return {
                        new: false,
                        promise: existingPromise,
                        keyObject,
                        cacheKey,
                    };
                }
                const dataPromise = fetchData(keyObject, isDev) || Promise.resolve(undefined);
                asyncRequests.set(cacheKey, dataPromise);
                return {
                    new: true,
                    promise: dataPromise,
                    keyObject,
                    cacheKey,
                };
            });
            fetchingObserver.notify();
            loadingObserver.notify();
            const results = await Promise.all(withPromises.map((val) => val.promise));
            withPromises.forEach((value, i) => {
                const promiseChanged = asyncRequests.get(value.cacheKey) !== value.promise;
                // if promise has changed in between, it means cache been invalidated or
                // new data are being fetched
                if (value.new && !promiseChanged) {
                    asyncRequests.delete(value.cacheKey);
                    const data = results[i];
                    if (data) {
                        addRecord(value.keyObject, data);
                    }
                    else if (!getRecord(value.keyObject)) {
                        // if no data exist, put empty object
                        addRecord(value.keyObject, {});
                    }
                }
            });
            fetchingObserver.notify();
            loadingObserver.notify();
            return withPromises.map((val) => getRecord(val.keyObject));
        }
        function getAllRecords() {
            const entries = Array.from(cache.entries());
            return entries.map(([key, entry]) => {
                return Object.assign(Object.assign({}, decodeCacheKey(key)), { data: entry.data });
            });
        }
        return Object.freeze({
            addStaticData,
            invalidate,
            addRecord,
            exists,
            getRecord,
            getTranslation,
            getTranslationNs,
            getTranslationFallback,
            changeTranslation,
            isFetching,
            isLoading,
            loadRecords,
            getAllRecords,
        });
    };

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    const defaultObserverOptions = {
        tagAttributes: {
            textarea: ['placeholder'],
            input: ['value', 'placeholder'],
            img: ['alt'],
            '*': ['aria-label', 'title'],
        },
        restrictedElements: ['script', 'style'],
        highlightKeys: ['Alt'],
        highlightColor: 'rgb(255, 0, 0)',
        highlightWidth: 5,
        inputPrefix: '%-%tolgee:',
        inputSuffix: '%-%',
        passToParent: ['option', 'optgroup'],
    };

    const DEFAULT_FORMAT_ERROR = 'invalid';
    const DEFAULT_API_URL = 'https://app.tolgee.io';
    const defaultValues = {
        defaultNs: '',
        observerOptions: defaultObserverOptions,
        observerType: 'invisible',
        onFormatError: DEFAULT_FORMAT_ERROR,
        apiUrl: DEFAULT_API_URL,
    };
    const combineOptions = (...states) => {
        let result = {};
        states.forEach((state) => {
            result = Object.assign(Object.assign(Object.assign({}, result), state), { observerOptions: Object.assign(Object.assign({}, result.observerOptions), state === null || state === void 0 ? void 0 : state.observerOptions) });
        });
        return result;
    };
    const initState = (options, previousState) => {
        const initialOptions = combineOptions(defaultValues, previousState === null || previousState === void 0 ? void 0 : previousState.initialOptions, options);
        // remove extra '/' from url end
        initialOptions.apiUrl = sanitizeUrl(initialOptions.apiUrl);
        return {
            initialOptions,
            activeNamespaces: (previousState === null || previousState === void 0 ? void 0 : previousState.activeNamespaces) || new Map(),
            language: previousState === null || previousState === void 0 ? void 0 : previousState.language,
            pendingLanguage: previousState === null || previousState === void 0 ? void 0 : previousState.language,
            isInitialLoading: false,
            isRunning: false,
        };
    };

    const Plugins = (getLanguage, getInitialOptions, getAvailableLanguages, getTranslationNs, getTranslation, changeTranslation) => {
        const plugins = {
            ui: undefined,
        };
        const instances = {
            formatters: [],
            finalFormatter: undefined,
            observer: undefined,
            devBackend: undefined,
            backends: [],
            ui: undefined,
            languageDetector: undefined,
            languageStorage: undefined,
        };
        const onClick = async ({ keysAndDefaults, event }) => {
            var _a;
            const withNs = keysAndDefaults.map(({ key, ns, defaultValue }) => {
                return {
                    key,
                    defaultValue,
                    ns: getTranslationNs({ key, ns }),
                    translation: getTranslation({
                        key,
                        ns,
                    }),
                };
            });
            (_a = instances.ui) === null || _a === void 0 ? void 0 : _a.handleElementClick(withNs, event);
        };
        const stop = () => {
            var _a;
            instances.ui = undefined;
            (_a = instances.observer) === null || _a === void 0 ? void 0 : _a.stop();
        };
        const highlight = (key, ns) => {
            var _a, _b;
            return ((_b = (_a = instances.observer) === null || _a === void 0 ? void 0 : _a.highlight) === null || _b === void 0 ? void 0 : _b.call(_a, key, ns)) || { unhighlight() { } };
        };
        const translate = (props) => {
            const translation = getTranslation({
                key: props.key,
                ns: props.ns,
            });
            return formatTranslation(Object.assign(Object.assign({}, props), { translation, formatEnabled: true }));
        };
        const setObserver = (observer) => {
            instances.observer = observer === null || observer === void 0 ? void 0 : observer();
        };
        const hasObserver = () => {
            return Boolean(instances.observer);
        };
        const addFormatter = (formatter) => {
            if (formatter) {
                instances.formatters.push(formatter);
            }
        };
        const setFinalFormatter = (formatter) => {
            instances.finalFormatter = formatter;
        };
        const setUi = (ui) => {
            plugins.ui = ui;
        };
        const hasUi = () => {
            return Boolean(plugins.ui);
        };
        const setLanguageStorage = (storage) => {
            instances.languageStorage = storage;
        };
        const getLanguageStorage = () => {
            return instances.languageStorage;
        };
        const setStoredLanguage = (language) => {
            var _a;
            (_a = instances.languageStorage) === null || _a === void 0 ? void 0 : _a.setLanguage(language);
        };
        const setLanguageDetector = (detector) => {
            instances.languageDetector = detector;
        };
        const getLanguageDetector = () => {
            return instances.languageDetector;
        };
        const detectLanguage = () => {
            if (!instances.languageDetector) {
                return undefined;
            }
            const availableLanguages = getAvailableLanguages();
            return instances.languageDetector.getLanguage({
                availableLanguages,
            });
        };
        const getInitialLanguage = () => {
            var _a;
            const availableLanguages = getAvailableLanguages();
            const languageOrPromise = (_a = instances.languageStorage) === null || _a === void 0 ? void 0 : _a.getLanguage();
            return valueOrPromise(languageOrPromise, (language) => {
                if ((!availableLanguages || availableLanguages.includes(language)) &&
                    language) {
                    return language;
                }
                return detectLanguage();
            });
        };
        const addBackend = (backend) => {
            if (backend) {
                instances.backends.push(backend);
            }
        };
        const setDevBackend = (backend) => {
            instances.devBackend = backend;
        };
        const run = () => {
            var _a, _b;
            const { apiKey, apiUrl, projectId, observerOptions } = getInitialOptions();
            instances.ui = (_a = plugins.ui) === null || _a === void 0 ? void 0 : _a.call(plugins, {
                apiKey: apiKey,
                apiUrl: apiUrl,
                projectId,
                highlight,
                changeTranslation,
            });
            (_b = instances.observer) === null || _b === void 0 ? void 0 : _b.run({
                mouseHighlight: true,
                options: observerOptions,
                translate,
                onClick,
            });
        };
        const getDevBackend = () => {
            return instances.devBackend;
        };
        const getBackendDevRecord = ({ language, namespace }) => {
            var _a;
            const { apiKey, apiUrl, projectId } = getInitialOptions();
            return (_a = instances.devBackend) === null || _a === void 0 ? void 0 : _a.getRecord({
                apiKey,
                apiUrl,
                projectId,
                language,
                namespace,
            });
        };
        const getBackendRecord = ({ language, namespace }) => {
            for (const backend of instances.backends) {
                const data = backend.getRecord({ language, namespace });
                if (isPromise(data)) {
                    return data === null || data === void 0 ? void 0 : data.catch((e) => {
                        // eslint-disable-next-line no-console
                        console.error(e);
                        return {};
                    });
                }
                if (data !== undefined) {
                    return data;
                }
            }
            return undefined;
        };
        const unwrap = (text) => {
            var _a;
            if (instances.observer) {
                return (_a = instances.observer) === null || _a === void 0 ? void 0 : _a.unwrap(text);
            }
            return { text, keys: [] };
        };
        const retranslate = () => {
            var _a;
            (_a = instances.observer) === null || _a === void 0 ? void 0 : _a.retranslate();
        };
        function addPlugin(tolgeeInstance, plugin) {
            const pluginTools = Object.freeze({
                setFinalFormatter,
                addFormatter,
                setObserver,
                hasObserver,
                setUi,
                hasUi,
                setDevBackend,
                addBackend,
                setLanguageDetector,
                setLanguageStorage,
            });
            plugin(tolgeeInstance, pluginTools);
        }
        function formatTranslation(_a) {
            var _b;
            var { formatEnabled } = _a, props = __rest(_a, ["formatEnabled"]);
            const { key, translation, defaultValue, noWrap, params, orEmpty, ns } = props;
            const formattableTranslation = translation || defaultValue;
            let result = formattableTranslation || (orEmpty ? '' : key);
            const language = getLanguage();
            const isFormatEnabled = formatEnabled || !((_b = instances.observer) === null || _b === void 0 ? void 0 : _b.outputNotFormattable);
            const wrap = (result) => {
                if (instances.observer && !noWrap) {
                    return instances.observer.wrap({
                        key,
                        translation: result,
                        defaultValue,
                        params,
                        ns,
                    });
                }
                return result;
            };
            result = wrap(result);
            try {
                if (formattableTranslation && language && isFormatEnabled) {
                    for (const formatter of instances.formatters) {
                        result = formatter.format({
                            translation: result,
                            language,
                            params,
                        });
                    }
                }
                if (instances.finalFormatter &&
                    formattableTranslation &&
                    language &&
                    isFormatEnabled) {
                    result = instances.finalFormatter.format({
                        translation: result,
                        language,
                        params,
                    });
                }
            }
            catch (e) {
                // eslint-disable-next-line no-console
                console.error(e);
                const errorMessage = getErrorMessage(e) || DEFAULT_FORMAT_ERROR;
                const onFormatError = getInitialOptions().onFormatError;
                const formatErrorType = typeof onFormatError;
                if (formatErrorType === 'string') {
                    result = onFormatError;
                }
                else if (formatErrorType === 'function') {
                    result = onFormatError(errorMessage, props);
                }
                else {
                    result = DEFAULT_FORMAT_ERROR;
                }
                // wrap error message, so it's detectable
                result = wrap(result);
            }
            return result;
        }
        function hasDevBackend() {
            return Boolean(getDevBackend());
        }
        const wrap = (params) => {
            var _a;
            if (instances.observer) {
                return (_a = instances.observer) === null || _a === void 0 ? void 0 : _a.wrap(params);
            }
            return params.translation;
        };
        return Object.freeze({
            addPlugin,
            formatTranslation,
            getDevBackend,
            getBackendRecord,
            getBackendDevRecord,
            getLanguageDetector,
            getLanguageStorage,
            getInitialLanguage,
            setStoredLanguage,
            run,
            stop,
            retranslate,
            highlight,
            unwrap,
            wrap,
            hasDevBackend,
        });
    };

    const ValueObserver = (initialValue, valueGetter, handler) => {
        let previousValue = initialValue;
        function init(value) {
            previousValue = value;
        }
        function notify() {
            const value = valueGetter();
            if (previousValue !== value) {
                handler(value);
            }
            previousValue = value;
        }
        return Object.freeze({
            init,
            notify,
        });
    };

    const State = (onLanguageChange, onPendingLanguageChange, onRunningChange) => {
        let state = initState();
        let devCredentials = undefined;
        function init(options) {
            state = initState(options, state);
        }
        function isRunning() {
            return state.isRunning;
        }
        function setRunning(value) {
            if (state.isRunning !== value) {
                state.isRunning = value;
                onRunningChange.emit(value);
            }
        }
        function isInitialLoading() {
            return state.isInitialLoading;
        }
        function setInitialLoading(value) {
            state.isInitialLoading = value;
        }
        function getLanguage() {
            return state.language || state.initialOptions.language;
        }
        function setLanguage(language) {
            if (state.language !== language) {
                state.language = language;
                onLanguageChange.emit(language);
            }
        }
        function getPendingLanguage() {
            return state.pendingLanguage || getLanguage();
        }
        function setPendingLanguage(language) {
            if (state.pendingLanguage !== language) {
                state.pendingLanguage = language;
                onPendingLanguageChange.emit(language);
            }
        }
        function getInitialOptions() {
            return Object.assign(Object.assign({}, state.initialOptions), devCredentials);
        }
        function addActiveNs(ns) {
            const namespaces = getFallbackArray(ns);
            namespaces.forEach((namespace) => {
                const value = state.activeNamespaces.get(namespace);
                if (value !== undefined) {
                    state.activeNamespaces.set(namespace, value + 1);
                }
                else {
                    state.activeNamespaces.set(namespace, 1);
                }
            });
        }
        function removeActiveNs(ns) {
            const namespaces = getFallbackArray(ns);
            namespaces.forEach((namespace) => {
                const value = state.activeNamespaces.get(namespace);
                if (value !== undefined && value > 1) {
                    state.activeNamespaces.set(namespace, value - 1);
                }
                else {
                    state.activeNamespaces.delete(namespace);
                }
            });
        }
        function getRequiredNamespaces() {
            return unique([
                ...(state.initialOptions.ns || [state.initialOptions.defaultNs]),
                ...getFallbackArray(state.initialOptions.fallbackNs),
                ...state.activeNamespaces.keys(),
            ]);
        }
        function getFallbackLangs(lang) {
            const language = lang || getLanguage();
            if (!language) {
                return [];
            }
            return unique([
                language,
                ...getFallbackFromStruct(language, state.initialOptions.fallbackLanguage),
            ]);
        }
        function getFallbackNs() {
            return getFallbackArray(state.initialOptions.fallbackNs);
        }
        function getDefaultNs(ns) {
            return ns === undefined ? state.initialOptions.defaultNs : ns;
        }
        function getAvailableLanguages() {
            if (state.initialOptions.availableLanguages) {
                return state.initialOptions.availableLanguages;
            }
            else if (state.initialOptions.staticData) {
                const languagesFromStaticData = Object.keys(state.initialOptions.staticData).map((key) => decodeCacheKey(key).language);
                return Array.from(new Set(languagesFromStaticData));
            }
        }
        function withDefaultNs(descriptor) {
            return {
                namespace: descriptor.namespace === undefined
                    ? getInitialOptions().defaultNs
                    : descriptor.namespace,
                language: descriptor.language,
            };
        }
        function overrideCredentials(credentials) {
            if (credentials) {
                devCredentials = Object.assign(Object.assign({}, credentials), { apiUrl: sanitizeUrl(credentials.apiUrl) });
            }
            else {
                devCredentials = undefined;
            }
        }
        return Object.freeze({
            init,
            isRunning,
            setRunning,
            isInitialLoading,
            setInitialLoading,
            getLanguage,
            setLanguage,
            getPendingLanguage,
            setPendingLanguage,
            getInitialOptions,
            addActiveNs,
            removeActiveNs,
            getRequiredNamespaces,
            getFallbackLangs,
            getFallbackNs,
            getDefaultNs,
            getAvailableLanguages,
            withDefaultNs,
            overrideCredentials,
        });
    };

    function parseCombinedOptions(_a) {
        var { ns, noWrap, orEmpty, params } = _a, rest = __rest(_a, ["ns", "noWrap", "orEmpty", "params"]);
        const options = {
            ns: ns,
            noWrap: noWrap,
            orEmpty: orEmpty,
        };
        return Object.assign(Object.assign({}, options), { params: Object.assign({}, rest) });
    }
    const getTranslateProps = (keyOrProps, ...params) => {
        let result = {};
        let options;
        if (typeof keyOrProps === 'object') {
            result = keyOrProps;
        }
        else {
            result.key = keyOrProps;
            if (typeof params[0] === 'string') {
                result.defaultValue = params[0];
                options = params[1];
            }
            else if (typeof params[0] === 'object') {
                options = params[0];
            }
        }
        if (options) {
            result = Object.assign(Object.assign({}, parseCombinedOptions(options)), result);
        }
        return result;
    };

    const Controller = ({ options }) => {
        const events = Events(getFallbackNs, getDefaultNs);
        const fetchingObserver = ValueObserver(false, () => cache.isFetching(), events.onFetchingChange.emit);
        const loadingObserver = ValueObserver(false, () => isLoading(), events.onLoadingChange.emit);
        const state = State(events.onLanguageChange, events.onPendingLanguageChange, events.onRunningChange);
        const pluginService = Plugins(state.getLanguage, state.getInitialOptions, state.getAvailableLanguages, getTranslationNs, getTranslation, changeTranslation);
        const cache = Cache(events.onCacheChange, pluginService.getBackendRecord, pluginService.getBackendDevRecord, state.withDefaultNs, state.isInitialLoading, fetchingObserver, loadingObserver);
        if (options) {
            init(options);
        }
        events.onUpdate.listen(() => {
            if (state.isRunning()) {
                pluginService.retranslate();
            }
        });
        function getFallbackNs() {
            return state.getFallbackNs();
        }
        function getDefaultNs(ns) {
            return state.getDefaultNs(ns);
        }
        // gets all namespaces where translation could be located
        // takes (ns|default, fallback ns)
        function getDefaultAndFallbackNs(ns) {
            return [...getFallbackArray(getDefaultNs(ns)), ...getFallbackNs()];
        }
        // gets all namespaces which need to be loaded
        // takes (ns|default, initial ns, fallback ns, active ns)
        function getRequiredNamespaces(ns) {
            return [
                ...getFallbackArray(ns || getDefaultNs()),
                ...state.getRequiredNamespaces(),
            ];
        }
        function changeTranslation(descriptor, key, value) {
            const keyObject = state.withDefaultNs(descriptor);
            const previousValue = cache.getTranslation(keyObject, key);
            cache.changeTranslation(keyObject, key, value);
            return {
                revert: () => {
                    cache.changeTranslation(keyObject, key, previousValue);
                },
            };
        }
        function init(options) {
            state.init(options);
            cache.addStaticData(state.getInitialOptions().staticData);
        }
        function isLoading(ns) {
            return cache.isLoading(state.getLanguage(), ns);
        }
        function isDev() {
            return Boolean(state.getInitialOptions().apiKey && state.getInitialOptions().apiUrl);
        }
        async function addActiveNs(ns, forget) {
            if (!forget) {
                state.addActiveNs(ns);
            }
            if (state.isRunning()) {
                await loadRequiredRecords(undefined, ns);
            }
        }
        function getRequiredRecords(lang, ns) {
            const languages = state.getFallbackLangs(lang);
            const namespaces = getRequiredNamespaces(ns);
            const result = [];
            languages.forEach((language) => {
                namespaces.forEach((namespace) => {
                    if (!cache.exists({ language, namespace }, true)) {
                        result.push({ language, namespace });
                    }
                });
            });
            return result;
        }
        function isLoaded(ns) {
            const language = state.getLanguage();
            if (!language) {
                return false;
            }
            const languages = state.getFallbackLangs(language);
            const namespaces = getRequiredNamespaces(ns);
            const result = [];
            languages.forEach((language) => {
                namespaces.forEach((namespace) => {
                    if (!cache.exists({ language, namespace })) {
                        result.push({ language, namespace });
                    }
                });
            });
            return result.length === 0;
        }
        function loadRequiredRecords(lang, ns) {
            const descriptors = getRequiredRecords(lang, ns);
            if (descriptors.length) {
                return valueOrPromise(loadRecords(descriptors), () => { });
            }
        }
        async function changeLanguage(language) {
            if (state.getPendingLanguage() === language &&
                state.getLanguage() === language) {
                return;
            }
            state.setPendingLanguage(language);
            if (state.isRunning()) {
                await loadRequiredRecords(language);
            }
            if (language === state.getPendingLanguage()) {
                // there might be parallel language change
                // we only want to apply latest
                state.setLanguage(language);
                pluginService.setStoredLanguage(language);
            }
        }
        function getTranslationNs({ key, ns }) {
            const languages = state.getFallbackLangs();
            const namespaces = getDefaultAndFallbackNs(ns || undefined);
            return cache.getTranslationNs(namespaces, languages, key);
        }
        function getTranslation({ key, ns }) {
            const namespaces = getDefaultAndFallbackNs(ns || undefined);
            const languages = state.getFallbackLangs();
            return cache.getTranslationFallback(namespaces, languages, key);
        }
        function loadInitial() {
            const data = valueOrPromise(initializeLanguage(), () => {
                // fail if there is no language
                return loadRequiredRecords();
            });
            if (isPromise(data)) {
                state.setInitialLoading(true);
                fetchingObserver.notify();
                loadingObserver.notify();
                return Promise.resolve(data).then(() => {
                    state.setInitialLoading(false);
                    fetchingObserver.notify();
                    loadingObserver.notify();
                    events.onInitialLoaded.emit();
                });
            }
            else {
                events.onInitialLoaded.emit();
            }
        }
        function initializeLanguage() {
            const existingLanguage = state.getLanguage();
            if (existingLanguage) {
                return;
            }
            if (!state.getInitialOptions().defaultLanguage) {
                throw new Error(missingOptionError('defaultLanguage'));
            }
            const languageOrPromise = pluginService.getInitialLanguage();
            return valueOrPromise(languageOrPromise, (lang) => {
                const language = lang ||
                    state.getInitialOptions().defaultLanguage;
                language && state.setLanguage(language);
            });
        }
        async function loadRecord(descriptor) {
            return (await loadRecords([descriptor]))[0];
        }
        function loadRecords(descriptors) {
            return cache.loadRecords(descriptors, isDev());
        }
        const checkCorrectConfiguration = () => {
            const languageComputable = pluginService.getLanguageDetector() || pluginService.getLanguageStorage();
            if (languageComputable) {
                const availableLanguages = state.getAvailableLanguages();
                if (!availableLanguages) {
                    throw new Error(missingOptionError('availableLanguages'));
                }
            }
            if (!state.getLanguage() && !state.getInitialOptions().defaultLanguage) {
                if (languageComputable) {
                    throw new Error(missingOptionError('defaultLanguage'));
                }
                else {
                    throw new Error(missingOptionError('language'));
                }
            }
        };
        function run() {
            let result = undefined;
            checkCorrectConfiguration();
            if (!state.isRunning()) {
                if (isDev()) {
                    cache.invalidate();
                }
                state.setRunning(true);
                pluginService.run();
                result = loadInitial();
            }
            return Promise.resolve(result);
        }
        function stop() {
            if (state.isRunning()) {
                pluginService.stop();
                state.setRunning(false);
            }
        }
        const t = (...args) => {
            // @ts-ignore
            const params = getTranslateProps(...args);
            const translation = getTranslation(params);
            return pluginService.formatTranslation(Object.assign(Object.assign({}, params), { translation }));
        };
        return Object.freeze(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, events), state), pluginService), cache), { init,
            changeLanguage,
            getTranslation,
            changeTranslation,
            addActiveNs,
            loadRecords,
            loadRecord,
            isLoading,
            isLoaded,
            t,
            isDev,
            run,
            stop }));
    };

    const createTolgee = (options) => {
        const controller = Controller({
            options,
        });
        // restarts tolgee while applying callback
        const withRestart = (callback) => {
            const wasRunning = controller.isRunning();
            wasRunning && controller.stop();
            callback();
            wasRunning && controller.run();
        };
        const tolgee = Object.freeze({
            /**
             * Listen to tolgee events.
             */
            on: controller.on,
            /**
             * Listen for specific namespaces changes.
             *
             * ```
             * const sub = tolgee.onUpdate(handler)
             *
             * // subscribe to selected namespace
             * sub.subscribeNs(['common'])
             *
             * // unsubscribe
             * sub.unsubscribe()
             * ```
             */
            onNsUpdate: controller.onUpdate.listenSome,
            /**
             * Turn off/on events emitting. Is on by default.
             */
            setEmmiterActive: controller.setEmmiterActive,
            /**
             * @return current language if set.
             */
            getLanguage: controller.getLanguage,
            /**
             * `pendingLanguage` represents language which is currently being loaded.
             * @return current `pendingLanguage` if set.
             */
            getPendingLanguage: controller.getPendingLanguage,
            /**
             * Change current language.
             * - if not running sets `pendingLanguage`, `language` to the new value
             * - if running sets `pendingLanguage` to the value, fetches necessary data and then changes `language`
             *
             * @return Promise which is resolved when `language` is changed.
             */
            changeLanguage: controller.changeLanguage,
            /**
             * Temporarily change translation in cache.
             * @return object with revert method.
             */
            changeTranslation: controller.changeTranslation,
            /**
             * Adds namespace(s) list of active namespaces. And if tolgee is running, loads required data.
             */
            addActiveNs: controller.addActiveNs,
            /**
             * Remove namespace(s) from active namespaces.
             *
             * Tolgee internally counts how many times was each active namespace added,
             * so this method will remove namespace only if the counter goes down to 0.
             */
            removeActiveNs: controller.removeActiveNs,
            /**
             * Manually load multiple records from `Backend` (or `DevBackend` when in dev mode)
             *
             * It loads data together and adds them to cache in one operation, to prevent partly loaded state.
             */
            loadRecords: controller.loadRecords,
            /**
             * Manually load record from `Backend` (or `DevBackend` when in dev mode)
             */
            loadRecord: controller.loadRecord,
            /**
             *
             */
            addStaticData: controller.addStaticData,
            /**
             * Get record from cache.
             */
            getRecord: controller.getRecord,
            /**
             * Get all records from cache.
             */
            getAllRecords: controller.getAllRecords,
            /**
             * @param ns optional list of namespaces that you are interested in
             * @return `true` if there are data that need to be fetched.
             */
            isLoaded: controller.isLoaded,
            /**
             * @return `true` if tolgee is loading initial data (triggered by `run`).
             */
            isInitialLoading: controller.isInitialLoading,
            /**
             * @param ns optional list of namespaces that you are interested in
             * @return `true` if tolgee is loading some translations for the first time.
             */
            isLoading: controller.isLoading,
            /**
             * @param ns optional list of namespaces that you are interested in
             * @return `true` if tolgee is fetching some translations.
             */
            isFetching: controller.isFetching,
            /**
             * @return `true` if tolgee is running.
             */
            isRunning: controller.isRunning,
            /**
             * Changes internal state to running: true and loads initial files.
             * Runs runnable plugins mainly Observer if present.
             */
            run: controller.run,
            /**
             * Changes internal state to running: false and stops runnable plugins.
             */
            stop: controller.stop,
            /**
             * Returns translated and formatted key.
             * If Observer is present and tolgee is running, wraps result to be identifiable in the DOM.
             */
            t: controller.t,
            /**
             * Highlight keys that match selection.
             */
            highlight: controller.highlight,
            /**
             * @return current Tolgee options.
             */
            getInitialOptions: controller.getInitialOptions,
            /**
             * Tolgee is in dev mode if `DevTools` plugin is used and `apiKey` + `apiUrl` are specified.
             * @return `true` if tolgee is in dev mode.
             */
            isDev: controller.isDev,
            /**
             * Wraps translation if there is `Observer` plugin
             */
            wrap: controller.wrap,
            /**
             * Unwrap translation
             */
            unwrap: controller.unwrap,
            /**
             * Override creadentials passed on initialization.
             *
             * When called in running state, tolgee stops and runs again.
             */
            overrideCredentials(credentials) {
                withRestart(() => controller.overrideCredentials(credentials));
            },
            /**
             * Add tolgee plugin after initialization.
             *
             * When called in running state, tolgee stops and runs again.
             */
            addPlugin(plugin) {
                if (plugin) {
                    withRestart(() => controller.addPlugin(tolgee, plugin));
                }
            },
            /**
             * Updates options after instance creation. Extends existing options,
             * so it only changes the fields, that are listed.
             *
             * When called in running state, tolgee stops and runs again.
             */
            updateOptions(options) {
                if (options) {
                    withRestart(() => controller.init(options));
                }
            },
        });
        return tolgee;
    };
    /**
     * Tolgee chainable constructor.
     *
     * Usage:
     * ```
     * const tolgee = Tolgee().use(...).init(...)
     * ```
     */
    const TolgeeCore = () => {
        const state = {
            plugins: [],
            options: {},
        };
        const tolgeeChain = Object.freeze({
            use(plugin) {
                state.plugins.push(plugin);
                return tolgeeChain;
            },
            updateDefaults(options) {
                state.options = combineOptions(state.options, options);
                return tolgeeChain;
            },
            init(options) {
                const tolgee = createTolgee(combineOptions(state.options, options));
                state.plugins.forEach(tolgee.addPlugin);
                return tolgee;
            },
        });
        return tolgeeChain;
    };

    const ERROR_PARAM_EMPTY = 0, ERROR_UNEXPECTED_CHAR = 1, ERROR_UNEXPECTED_END = 2;
    class FormatError extends Error {
        constructor(code, index, text) {
            let error;
            if (code === ERROR_PARAM_EMPTY) {
                error = 'Empty parameter';
            }
            else if (code === ERROR_UNEXPECTED_CHAR) {
                error = 'Unexpected character';
            }
            else {
                error = 'Unexpected end';
            }
            super(`Tolgee parser: ${error} at ${index} in "${text}"`);
            this.code = code;
            this.index = index;
        }
    }

    function isWhitespace(ch) {
        return /\s/.test(ch);
    }
    const STATE_TEXT = 0, STATE_ESCAPE_MAYBE = 1, STATE_ESCAPE = 2, STATE_PARAM = 3, STATE_PARAM_AFTER = 4;
    const END_STATES = new Set([
        STATE_ESCAPE,
        STATE_ESCAPE_MAYBE,
        STATE_TEXT,
    ]);
    const CHAR_ESCAPE = "'";
    const ESCAPABLE = new Set(['{', '}', CHAR_ESCAPE]);
    const isAllowedInParam = (char) => {
        return /[0-9a-zA-Z_]/.test(char);
    };
    function formatParser(translation) {
        let state = STATE_TEXT;
        let text = '';
        let param = '';
        let ch = '';
        const texts = [];
        const params = [];
        let i = 0;
        function parsingError(code) {
            throw new FormatError(code, i, translation);
        }
        const addText = () => {
            texts.push(text);
            text = '';
        };
        const addParamChar = () => {
            if (!isAllowedInParam(ch)) {
                parsingError(ERROR_UNEXPECTED_CHAR);
            }
            param += ch;
        };
        const addParam = () => {
            if (param === '') {
                parsingError(ERROR_PARAM_EMPTY);
            }
            params.push(param);
            param = '';
        };
        for (i = 0; i < translation.length; i++) {
            ch = translation[i];
            switch (state) {
                case STATE_TEXT:
                    if (ch === CHAR_ESCAPE) {
                        text += ch;
                        state = STATE_ESCAPE_MAYBE;
                    }
                    else if (ch === '{') {
                        addText();
                        state = STATE_PARAM;
                    }
                    else {
                        text += ch;
                        state = STATE_TEXT;
                    }
                    break;
                case STATE_ESCAPE_MAYBE:
                    if (ESCAPABLE.has(ch)) {
                        text = text.slice(0, -1) + ch;
                        state = STATE_ESCAPE;
                    }
                    else {
                        text += ch;
                        state = STATE_TEXT;
                    }
                    break;
                case STATE_ESCAPE:
                    if (ch === CHAR_ESCAPE) {
                        state = STATE_TEXT;
                    }
                    else {
                        text += ch;
                        state = STATE_ESCAPE;
                    }
                    break;
                case STATE_PARAM:
                    if (ch === '}') {
                        addParam();
                        state = STATE_TEXT;
                    }
                    else if (!isWhitespace(ch)) {
                        addParamChar();
                        state = STATE_PARAM;
                    }
                    else if (param !== '') {
                        addParam();
                        state = STATE_PARAM_AFTER;
                    }
                    break;
                case STATE_PARAM_AFTER:
                    if (ch == '}') {
                        state = STATE_TEXT;
                    }
                    else if (isWhitespace(ch)) {
                        state = STATE_PARAM_AFTER;
                    }
                    else {
                        parsingError(ERROR_UNEXPECTED_CHAR);
                    }
            }
        }
        if (!END_STATES.has(state)) {
            parsingError(ERROR_UNEXPECTED_END);
        }
        addText();
        return [texts, params];
    }

    function formatter(translation, params) {
        const [texts, pars] = formatParser(translation);
        const result = [texts[0]];
        for (let i = 1; i < texts.length; i++) {
            const parameter = params === null || params === void 0 ? void 0 : params[pars[i - 1]];
            if (parameter === undefined) {
                throw new Error(`Missing parameter "${pars[i - 1]}" in "${translation}"`);
            }
            result.push(String(parameter));
            result.push(texts[i]);
        }
        return result.join('');
    }

    function createFormatSimple() {
        return {
            format: ({ translation, params }) => formatter(translation, params),
        };
    }
    const FormatSimple = () => (tolgee, tools) => {
        tools.setFinalFormatter(createFormatSimple());
        return tolgee;
    };

    exports.FormatSimple = FormatSimple;
    exports.TolgeeCore = TolgeeCore;
    exports.getFallback = getFallback;
    exports.getFallbackArray = getFallbackArray;
    exports.getTranslateProps = getTranslateProps;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=tolgee.umd.js.map
