import { normSpaces, IN_BROWSER, getLabelAttribute, hasOpenreplayAttribute } from "../utils.js";
import { SetInputTarget, SetInputValue, SetInputChecked } from "../messages/index.js";
function isTextEditable(node) {
    if (node instanceof HTMLTextAreaElement) {
        return true;
    }
    if (!(node instanceof HTMLInputElement)) {
        return false;
    }
    const type = node.type;
    return (type === 'text' ||
        type === 'password' ||
        type === 'email' ||
        type === 'search' ||
        type === 'number' ||
        type === 'range');
}
function isCheckable(node) {
    if (!(node instanceof HTMLInputElement)) {
        return false;
    }
    const type = node.type;
    return type === 'checkbox' || type === 'radio';
}
const labelElementFor = IN_BROWSER && 'labels' in HTMLInputElement.prototype
    ? (node) => {
        let p = node;
        while ((p = p.parentNode) !== null) {
            if (p.nodeName === 'LABEL') {
                return p;
            }
        }
        const labels = node.labels;
        if (labels !== null && labels.length === 1) {
            return labels[0];
        }
    }
    : (node) => {
        let p = node;
        while ((p = p.parentNode) !== null) {
            if (p.nodeName === 'LABEL') {
                return p;
            }
        }
        const id = node.id;
        if (id) {
            const labels = document.querySelectorAll('label[for="' + id + '"]');
            if (labels !== null && labels.length === 1) {
                return labels[0];
            }
        }
    };
export function getInputLabel(node) {
    let label = getLabelAttribute(node);
    if (label === null) {
        const labelElement = labelElementFor(node);
        label =
            labelElement === undefined
                ? node.placeholder || node.name
                : labelElement.innerText;
    }
    return normSpaces(label).slice(0, 100);
}
export default function (app, opts) {
    const options = Object.assign({
        obscureInputNumbers: true,
        obscureInputEmails: true,
        defaultInputMode: 0 /* Plain */,
    }, opts);
    function sendInputTarget(id, node) {
        const label = getInputLabel(node);
        if (label !== '') {
            app.send(new SetInputTarget(id, label));
        }
    }
    function sendInputValue(id, node) {
        let value = node.value;
        let inputMode = options.defaultInputMode;
        if (node.type === 'password' || hasOpenreplayAttribute(node, 'hidden')) {
            inputMode = 2 /* Hidden */;
        }
        else if (hasOpenreplayAttribute(node, 'obscured') ||
            (inputMode === 0 /* Plain */ &&
                ((options.obscureInputNumbers && /\d\d\d\d/.test(value)) ||
                    (options.obscureInputEmails &&
                        (node.type === 'email' || !!~value.indexOf('@')))))) {
            inputMode = 1 /* Obscured */;
        }
        let mask = 0;
        switch (inputMode) {
            case 2 /* Hidden */:
                mask = -1;
                value = '';
                break;
            case 1 /* Obscured */:
                mask = value.length;
                value = '';
                break;
        }
        app.send(new SetInputValue(id, value, mask));
    }
    const inputValues = new Map();
    const checkableValues = new Map();
    const registeredTargets = new Set();
    app.attachStopCallback(() => {
        inputValues.clear();
        checkableValues.clear();
        registeredTargets.clear();
    });
    app.ticker.attach(() => {
        inputValues.forEach((value, id) => {
            const node = app.nodes.getNode(id);
            if (!isTextEditable(node)) {
                inputValues.delete(id);
                return;
            }
            if (value !== node.value) {
                inputValues.set(id, node.value);
                if (!registeredTargets.has(id)) {
                    registeredTargets.add(id);
                    sendInputTarget(id, node);
                }
                sendInputValue(id, node);
            }
        });
        checkableValues.forEach((checked, id) => {
            const node = app.nodes.getNode(id);
            if (!isCheckable(node)) {
                checkableValues.delete(id);
                return;
            }
            if (checked !== node.checked) {
                checkableValues.set(id, node.checked);
                app.send(new SetInputChecked(id, node.checked));
            }
        });
    });
    app.ticker.attach(Set.prototype.clear, 100, false, registeredTargets);
    app.nodes.attachNodeCallback(app.safe((node) => {
        const id = app.nodes.getID(node);
        if (id === undefined) {
            return;
        }
        if (isTextEditable(node)) {
            inputValues.set(id, node.value);
            sendInputValue(id, node);
            return;
        }
        if (isCheckable(node)) {
            checkableValues.set(id, node.checked);
            app.send(new SetInputChecked(id, node.checked));
            return;
        }
    }));
}
